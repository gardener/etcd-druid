# controllers

etcd-druid is an operator of etcd clusters, and follows the
[`Operator`](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) pattern for Kubernetes.
It makes use of the [Kubebuilder](https://github.com/kubernetes-sigs/kubebuilder) framework which makes it quite easy 
to define Custom Resources (CRs) through 
[*Custom Resource Definitions*](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/)
(CRDs), and define controllers for these CRDs.
etcd-druid uses Kubebuilder to define the `Etcd` CR and its correspdonding controllers.
<!--- the autogenerated API documents are to be linked for the etcd CR  -->

All controllers that are a part of etcd-druid reside in package `pkg/controllers`, as subpackages.

There are 5 controllers that are a part of etcd-druid with each having its own specific responsibility:

- *etcd* : responsible for the reconciliation of the `Etcd` CR.
- *custodian* : responsible for updation of the status of the `Etcd` CR.
- *compaction* : responsible for [snapshot compaction](/docs/proposals/02-snapshot-compaction.md).
- *etcdcopybackupstask* : responsible for the copying the snapshot backups from one object store to another.
- *secret* : responsible in making sure `Secret`s are not deleted while in use.

## package structure

The typical package structure for the controllers that are part of etcd-druid is shown with the *custodian controller*:

``` bash
controllers/custodian
├── config.go
├── reconciler.go
└── register.go
````

- `config.go`: contains all the logic for the configuration of the controller.
- `register.go`: contains the logic for registering the controller with the manager.
- `reconciler.go`: contains the controller logic.

Each controller package also contains auxiliary files which are relevant to that specific controller.

## controller manager

A *manager* is first created for all controllers that are a part of etcd-druid.
The *controller manager* is responsible for all the controllers that are associated with CRDs.
Once the manager is `Start()`-ed, all the controllers that are *registered* with it are started.  
It is analogous to the Kuberenetes Controller Manager in that it is responsible for running all the controllers
that are defined by the consumer of Kubebuilder, the way Kubernetes Controller Manager is responsible for running the
inbuilt controller in Kubernetes, for its consumer.

While building each controller before registering with the manager, each controller is configured according to its
specific use case. Configuration like the type of object being reconciled, owned objects whose owner object is
reconciled, event filters (predicates), are passed to the builder.  
Predicates are filters which allow controllers to filter which type of events the controller should respond to and
which type of events the controllers must reject.

The logic relevant to the controller manager like the creation of the controller manager, registering the controllers
with the managers are done in [`controllers/manager.go`](/controllers/manager.go)

## etcd controller - **subject to change soon - WIP**

The *etcd controller* is responsible for the reconciliation of the `Etcd` resource.
It handles the provisioning and operation of the etcd cluster. Different components that are required for the 
functioning of the cluster like `Leases`, `ConfigMap`s, and the `Statefulset` for the etcd cluster are all deployed and 
managed by the *etcd controller*.

While building the controller, an event filter is set such that the behaviour of the controller depends on the
`gardener.cloud/operation:reconcile` *annotation*. The controller can be made either to obey this annotation
and perform reconciliation only when this annotation is present, or perform reconciliation under conditions which
typically trigger reconciliation.  
The reason this filter is present is because any disruption in the `Etcd` resource due to reconciliation 
(due to changes in the `Etcd` spec, for example) while workloads are being run would be disastrous. 
Another reason for the filter's existence is that the reconciliation of the `Etcd` resource is quite resource
intensive, and a reconcile due to every event which is related to `Etcd` or objects owned would not be efficient.  
Reconciliation of the `Etcd` resource thus happens only in
[*maintenance windows*](https://github.com/gardener/gardener/blob/master/docs/usage/shoot_maintenance.md).

To prevent deletion of the components which are necessary for the functioning of the system, the *etcd controller*
adds finalizers to resources it deploys to ensures that they are not deleted while the system still relies on them
for proper functioning. Only the *etcd controller* can delete a resource once it adds finalizers to it.
It adds a finalizer to the `Etcd` resource in order to ensure that the `Etcd` instance does not get deleted while
the system is still dependent on the existence of the `Etcd` resource. 

When the *etcd controller* enters the deletion flow, components are deleted in the reverse order that they were
deployed in.

The *etcd controller* is essential to the functioning of the etcd cluster and etcd-druid, thus the minimum number of
worker threads is 1 (default being 3).

## custodian controller - **subject to change soon - WIP** 

The *custodian controller* acts on the `Etcd` resource.
The primary purpose of the *custodian controller* is to update the status of the `Etcd` resource.

It watches for changes in the status of the `Statefulset`s associated with the `Etcd` resources.
Even though the `Etcd` resource owns the `Statefulset`, it is not necessary that the *etcd controller* 
reconciles whenever there are changes in the statuses of the objects that the `Etcd` resource owns.
To reflect changes that occur in the `Statefulset` status in the `Etcd` resource, the *custodian controller*
keeps a watch on the `Statefulset`.

The *custodian controller* reconciles periodically. It also reconciles whenever there are changes to
the `Statefulset` status.

The *custodian controller* is essential to the functioning of etcd-druid, thus the minimum number of
worker threads is 1, (default being 3).

## compaction controller

The *compaction controller* deploys the snapshot compaction job whenever required.
The controller watches the number of delta events occurences and triggers a snapshot compaction when the number of
delta events crosses the set threshold (1M events by default, which is configurable).

The controller watches for changes in "snapshot" `Leases` associated with `Etcd` resources.
It checks the full and delta snapshot `Leases` and calculates the difference in events between the latest
delta snapshot and the previous full snapshot, and initiates the compaction job if the event threshold is crossed.

The number of worker threads for the *compaction controller* needs to be greater than or equal to 0 (default 3).
This is unlike other controllers who need atleast one worker thread for the proper functioning of etcd-druid.
This is because snapshot compaction is not a core functionality for the etcd clusters to be deployed.

## etcdcopybackupstask controller

The *etcdcopybackupstask controller* is responsible for deploying the snapshot copy job.

Whenever `EtcdCopyBackupsTask` resources are deployed or updated, the *etcdcopybackupstask controller* picks up these
events from the event queue.
The `EtcdCopyBackupsTask` uses the etcd-backup-restore image, and deploys it as a job. The argument used for the job
is the `copy` command of `etcdbrctl`, and has the source and target storage providers as arguments when creating
the job resource instance.

The number of worker threads for the *etcdcopybackupstask controller* needs to be greater than or equal to 0 (default
being 3). This is unlike other controllers who need atleast one worker thread for the proper functioning of etcd-druid.
This is because etcdcopybackupstask is not a core functionality for the etcd clusters to be deployed.

## secret controller

The *secret controller*'s primary responsibility is to add a finalizer on `Secret`s referenced by the `Etcd` resource.
The *secret controller* is registered for `Secret`s, and the controller keeps a watch on the `Etcd` CR.
This finalizer is added to ensure that `Secret`s which are referenced by the `Etcd` CR aren't deleted while still
being used by the `Etcd` resource.

Events which involve the `Etcd` CR which refer to a `Secret` are enqueued into the request queue, which the reconciler
acts on.  
The controller reconciles whenever necessary events are queued in, and thus is triggered automatically.

The number of worker threads for the secret controller must be atleast 1 (default being 10), since infrastructure
access to store snapshots is essential to the proper functioning of etcd-druid.
